<!DOCTYPE html>
<html>
<head>
    <title>DuckDB</title>
    <link rel="stylesheet" href="http://codemirror.net/lib/codemirror.css">
    <link rel="stylesheet" href="http://codemirror.net/addon/hint/show-hint.css">
    <link rel="stylesheet" href="./static/css/sortable-theme-bootstrap.css" />
    <link rel="stylesheet" href="./static/css/xdialog.3.4.0.min.css">
    <link rel="stylesheet" href="./static/css/styles.css" />
    
    <script src="http://codemirror.net/lib/codemirror.js"></script>
    <script src="http://codemirror.net/addon/edit/matchbrackets.js"></script>
    <script src="http://codemirror.net/mode/sql/sql.js"></script>
    <script src="http://codemirror.net/addon/hint/show-hint.js"></script>
    <script src="http://codemirror.net/addon/hint/sql-hint.js"></script>
    <script src="http://codemirror.net/addon/comment/comment.js"></script>
    <script src="http://pure.github.io/pure/libs/pure.js"></script>
    <script src="https://unpkg.com/canvas-datagrid"></script>
    <script src="./static/js/pg_query.js"></script>
    <script src="./static/js/sortable.js"></script>
    <script src="./static/js/pgsql_parser.js"></script>
    <script src="./static/js/script.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@6.1.5/build/iife/with-async-ittr-min.js"></script>
    <script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js"></script>
    <!-- <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script> -->
    <!-- <script src="./static/js/localforage.js"></script> -->
</head>

<body>
<div>
    <div class="splitter_pane">
        <div id="first">
            <div style="float: left;">
                <button type="button" class="btn" onclick="onClickPlay()"><img src="/static/images/play.svg" style="width: 15px; margin: 0;"></button>
                <br><br>
                <button type="button" class="btn tooltip hidden" onclick="onClickCancel()" id="cancel_button">
                    <img src="/static/images/cancel.svg" style="width: 15px; margin: 0;">
                    <span class="tooltiptext tooltip-right">If click this button, the query will be stopped right away and initialized database</span>
                </button>
            </div>
            <textarea rows="4" cols="50" name="textarea_sql_editer" id="textarea_sql_editer">
# Use '--' or '#' for comments.
-- space needed after '--'
-- use semicolon (;) at the end of multiline query

SELECT 1 AS "Result"
    UNION SELECT 2
    UNION SELECT 3;
            </textarea>
            <div style="max-height: 52px;">
                <div class="file_browser_container">
                    <!-- <label for="file-input">
                        <img src="/static/images/upload.svg" style="width: 30px;"/>
                    </label>
                    <input id="file-input" type="file" /> -->
                    <label for="qfile">Select files:</label>
                    <input type="file" id="qfile" name="qfile" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                    <!-- <button onclick="mount_duckdb_dir()">Mount DuckDB Directory</button> -->
                </div>
                <div id="query_status">&nbsp;</div>
                <div class="loader" id="loader">
                    <div class="inner one"></div>
                    <div class="inner two"></div>
                    <div class="inner three"></div>
                </div>
            </div>
            <div id="grid"></div>
        </div>
        <div id="separator" ></div>
        <div id="second">
            <!-- <div class="loader" id="pageloader">
                <div class="inner one"></div>
                <div class="inner two"></div>
                <div class="inner three"></div>
            </div> -->
            <!-- <select id="select_fields" style="width: 120px;"></select>
            <input id="txt_field_value">
            <button onclick="change_table()">Change</button> -->
            <section id="files_section">
                <div class="tab">
                    <button class="tablinks" onclick="showTable(event, 't_files')">Files</button>
                </div>
                <div class="t_files_container">
                    <table class="sortable-theme-bootstrap" data-sortable name="t_files" id="t_files">
                        <thead id="thead">
                            <tr>
                                <th></th>
                                <th class="middle_align">Name</th>
                                <th class="middle_align">Size</th>
                                <th class="middle_align">Last Modified</th>
                                <th class="middle_align">Table Slug</th>
                                <th class="middle_align">Local Table</th>
                                <th class="middle_align">Local Parquet</th>
                                <th class="middle_align">Remote Parquet</th>
                                <th class="middle_align">Remote Table(BQ)</th>
                                <th class="middle_align">Suggested Source</th>
                            </tr>
                        </thead>
                        <tbody id="t_files_tbody">
                        </tbody>
                    </table>
                </div>
            </section>
            <section id="tables_section">
                <div class="tab">
                    <button class="tablinks" onclick="showTable(event, 't_tables')">Tables</button>
                </div>
                <div class="t_tables_container">
                    <table class="sortable-theme-bootstrap" data-sortable name="t_tables" id="t_tables">
                        <thead id="thead">
                            <tr>
                                <th></th>
                                <th class="middle_align">Name</th>
                                <th class="middle_align">Primary Key</th>
                                <th class="middle_align">Local Parquet</th>
                                <th class="middle_align">Remote Parquet</th>
                                <th class="middle_align">Remote BQTable</th>
                            </tr>
                        </thead>
                        <tbody id="t_tables_tbody">
                        </tbody>
                    </table>
                </div>
            </section>
            <section id="logs_section">
                <div class="tab">
                    <button class="tablinks" onclick="showTable(event, 't_logs')">Logs</button>
                </div>
                <table class="sortable-theme-bootstrap" data-sortable name="t_logs" id="t_logs">
                    <thead id="thead">
                        <tr>
                            <th>EventType</th>
                            <th>Timestamp</th>
                            <th>Duration</th>
                            <th>Text</th>
                        </tr>
                    </thead>
                    <tbody id="t_logs_tbody">
                    </tbody>
                </table>
            </section>
        </div>
    </div>
</div>

<script type="module">
    // Import the functions you need from the SDKs you need
    const firebaseConfig = {
        apiKey: "apiKey",
        authDomain: "authDomain",
        databaseURL: "databaseURL",
        projectId: "projectId",
        storageBucket: "storageBucket",
        messagingSenderId: "messagingSenderId",
        appId: "appId"
    };
    
    const firebase = await import(`https://www.gstatic.com/firebasejs/9.4.0/firebase-app.js`);
    window.firebaseApp = firebase.initializeApp(firebaseConfig);
    window.firestorage = await import(`https://www.gstatic.com/firebasejs/9.4.0/firebase-storage.js`);
    window.firedb = await import(`https://www.gstatic.com/firebasejs/9.4.0/firebase-database.js`);
    window.fireFuncs = await import(`https://www.gstatic.com/firebasejs/9.4.0/firebase-functions.js`);
</script>
<script src="./static/js/xdialog.3.4.0.min.js"></script>
<script>
    const libraryVersion = "0.1.12-dev89.0";
    const projectId = "first-outlet-750", tableId = "DuckDBStore";
    const distURL = `https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@${libraryVersion}/dist/`;
    const BQUERY_URL = `https://bigquery.googleapis.com/bigquery/v2/projects/${projectId}/queries`

    const TABLE_ICON_NONE = 0, TABLE_ICON_PREVIEW = 1, TABLE_ICON_REFRESH = 2, TABLE_ICON_REMOVE = 3;
    const TID_FILES = "t_files", TID_TABLES = "t_tables", TID_LOGS = "t_logs", TID_ALL = "t_all";
    const EVENT_TYPE_TABLE = 0, EVENT_TYPE_FILE = 1, EVENT_TYPE_QUERY = 2;
    const EVENT_TYPES = ["TABLE", "FILE", "QUERY"]
    const CELL_COLORS = ['#aeedcf', '#c1e993', '#7be7dd', '#ffbc5a', '#c6cfff', '#f3e781', '#c3f376']

    var duck_dbs = [], duckdb_wasmURL, duckdb_pThreadURL;
    var sql_editer, sql_parser;
    var canvasgrid;
    var cancel_query = false, first_result = false;
    var client_id;
    var internal_tables = [], event_logs = [], parquet_buffer = {}, selected_source = {};
    var ctidx; // current table index
    var qtname; // queried table name
    var f_storage, f_db, f_funcs, i_db, fb_conn;
    var bqtoken;
    var edit_start_time;
    var grid_active_rowIndex = -1, grid_active_columnIndex = -1;
    var clients = {}, sharedData = {}, pending_tables = {};
  
    DUCKDB_BUNDLES = ({
        asyncDefault: {
            mainModule: new URL('duckdb.wasm', distURL).toString(),
            mainWorker: new URL('duckdb-browser-async.worker.js', distURL).toString(),
        },
        asyncNext: {
            mainModule: new URL(`duckdb-next.wasm`, distURL).toString(),
            mainWorker: new URL('duckdb-browser-async-next.worker.js', distURL).toString(),
        },
        asyncNextCOI: {
            mainModule: new URL('duckdb-next-coi.wasm', distURL).toString(),
            mainWorker: new URL('duckdb-browser-async-next-coi.worker.js', distURL).toString(),
            pthreadWorker: new URL('duckdb-browser-async-next-coi.pthread.worker.js', distURL).toString(),
        },
    })

    async function make_duckdb() {
        const logger = new duckdb.ConsoleLogger();
        const worker = new Worker(workerURL);
        const db = new duckdb.AsyncDuckDB(logger, worker);
        await db.instantiate(duckdb_wasmURL, duckdb_pThreadURL);
        console.log(db.getVersion());

        return db;
    }

    async function register_parquet_buffer() {
        if (duck_dbs.length != 3) {
            setTimeout(register_parquet_buffer, 1000);
            return;
        }

        for (let t of internal_tables) {
            if (t.parquet && parquet_buffer[t.parquet.name]) {
                for (let i=0; i<duck_dbs.length; i++) {
                    await duck_dbs[i].instance.registerFileBuffer(t.parquet.name, parquet_buffer[t.parquet.name]);
                }
            }
            if (t.parquet && t.parquet.remote) {
                for (let i=0; i<duck_dbs.length; i++) {
                    await duck_dbs[i].instance.registerFileURL(t.parquet.remote, `https://firebasestorage.googleapis.com/v0/b/first-outlet-750.appspot.com/o/${t.parquet.remote}?alt=media`);
                }
            }
        }
    }

    async function init_firebase() {
        try {
            f_storage = firestorage.getStorage(firebaseApp);
            f_db = firedb.getDatabase(firebaseApp);
            f_funcs = fireFuncs.getFunctions(firebaseApp);
            const dbRef = firedb.ref(f_db);
            let snapshot = await firedb.get(firedb.child(dbRef, 'duckdb')), tables;

            if (snapshot.exists()) {
                data = snapshot.val()
                for (k in data) {
                    const tx = i_db.transaction('parquets', 'readwrite');
                    const store = tx.objectStore('parquets');
                    let parquetbuff = (await store.get(data[k].file.hash)) || 0;
                    if (parquetbuff && data[k].parquet && data[k].parquet.name) parquet_buffer[data[k].parquet.name] = parquetbuff;
                    data[k].table.localtable = '';
                    data[k].table.icon = TABLE_ICON_PREVIEW;
                    internal_tables.push(data[k]);
                }
                setTimeout(register_parquet_buffer, 1000);
            } else {
                console.log("No data available");
            }
            refresh_tables();

            firedb.onValue(firedb.ref(firedb.getDatabase(), 'events/editcell'), eventEditCellHandler);
            firedb.onValue(firedb.ref(firedb.getDatabase(), 'events/offline_update'), eventOfflineUpdateHandler);
            firedb.onValue(firedb.ref(firedb.getDatabase(), 'events/cursor'), eventCursorHandler);
            firedb.onValue(firedb.ref(f_db, ".info/connected"), processFirebaseConnection);

            snapshot = await firedb.get(firedb.child(dbRef, 'events/cells'));
            if (snapshot.exists()) {
                tables = snapshot.val()
                for (let t in tables) {
                    initSharedData(t);
                    for (let k in tables[t]) {
                        for (let f in tables[t][k]) {
                            if (sharedData[t] && sharedData[t][k] && sharedData[t][k][f]) {
                                if (sharedData[t][k][f][1] < tables[t][k][f][1]) {
                                    sharedData[t][k][f] = tables[t][k][f];
                                }
                            } else {
                                if (!sharedData[t]) sharedData[t] = {};
                                if (!sharedData[t][k]) sharedData[t][k] = {};
                                sharedData[t][k][f] = tables[t][k][f];
                            }
                        }
                    }
                }
            }

            fb_conn = true;
            return;
        } catch (e) {
            console.log(e.message);
        }
        setTimeout(init_firebase, 200);
    }

    function processFirebaseConnection(ev) {
        if (ev.val() === true) {
            console.log("firebase -- connected --");
            fb_conn = true;
            for (tname in pending_tables) {
                if (pending_tables[tname])
                    uploadSharedData(tname);
            }
        } else {
            console.log("firebase -- disconnected --");
            fb_conn = false;
        }
    }

    function eventCursorHandler(ev) {
        clients.cursors = ev.val();
        canvasgrid.draw();
    }

    function eventOfflineUpdateHandler(ev) {
        const updates = ev.val();
        if (!updates) return;

        if (updates[client_id] && Object.keys(sharedData).length == 0) {
            sharedData = JSON.parse(pako.inflate(atob(updates[client_id]), { to: 'string' }));
        }

        for (let id in updates) {
            if (id != client_id) {
                let tables = JSON.parse(pako.inflate(atob(updates[id]), { to: 'string' }));
                for (let t in tables) {
                    let log = true;
                    for (let k in tables[t]) {
                        for (let f in tables[t][k]) {
                            if (sharedData[t] && sharedData[t][k] && sharedData[t][k][f]) {
                                if (sharedData[t][k][f][1] < tables[t][k][f][1]) {
                                    if (log) {
                                        console.log(Date.now() - tables[t][k][f][1]);
                                        log = false;
                                    }
                                    sharedData[t][k][f] = tables[t][k][f];
                                }
                            } else {
                                if (!sharedData[t]) sharedData[t] = {};
                                if (!sharedData[t][k]) sharedData[t][k] = {};
                                sharedData[t][k][f] = tables[t][k][f];
                            }
                        }
                    }
                }
            }
        }
        update_canvasgrid();
    }

    function eventEditCellHandler(ev) {
        const data = ev.val();
        if (data.clientId != client_id) {
            if (ctidx && data.tableName == internal_tables[ctidx].table.name) {
                const f = data.field, pk = internal_tables[ctidx].table.pk;
                for (let i=0; i<canvasgrid.data.length; i++) {
                    if (canvasgrid.data[i][pk] == data.row[pk]) {
                        canvasgrid.data[i][f] = data.newValue;
                        save_logs(EVENT_TYPE_TABLE, data.edit_start_time, data.edit_end_time, `Table "${internal_tables[ctidx].table.name}" was changed by ${data.clientId}`);
                        break;
                    }
                }
                canvasgrid.draw();
            }
        }
    }

    function onBeginEditTable(e) {
        if (ctidx) {
            if (!internal_tables[ctidx].table.pk) {
                xdialog.alert("You have to set Primary Key before editing table");
                canvasgrid.blur();
                return;
            }

            edit_start_time = Date.now();
            onClickGrid(e);
        }
    }

    function onEndEditTable(e) {
        if (e.oldValue != e.newValue && ctidx && internal_tables[ctidx].table.pk) {
            const edit_end_time = Date.now(), tname = internal_tables[ctidx].table.name;
            initSharedData(tname);
            const fields = sharedData[tname]["fields"], pk_field = internal_tables[ctidx].table.pk, pk_value = e.cell.data[pk_field];
            if (!sharedData[tname][pk_value]) sharedData[tname][pk_value] = {};
            sharedData[tname][pk_value][fields[e.cell.header.name]] = [e.newValue, edit_end_time];

            const ret = sendDataToFirebase('events/editcell', {
                clientId: client_id,
                tableName: tname,
                row: e.cell.data,
                field: e.cell.header.name,
                newValue: e.newValue,
                edit_start_time: edit_start_time,
                edit_end_time: edit_end_time
            });

            if (ret) {
                sendDataToFirebase('events/cells/'+tname+'/'+pk_value+'/'+fields[e.cell.header.name], sharedData[tname][pk_value][fields[e.cell.header.name]]);
            } else {
                pending_tables[tname] = true;
            }
            
            save_event_logs(EVENT_TYPE_TABLE, `Changed table "${internal_tables[ctidx].table.name}"`, edit_start_time, edit_end_time);
        }
    }

    function onAfterPaste(e) {
        if (!ctidx) return;
        
        const tname = internal_tables[ctidx].table.name;
        initSharedData(tname);

        const fields = sharedData[tname]["fields"], pk_field = internal_tables[ctidx].table.pk;
        const schema = canvasgrid.schema;
        let pk_value, f;
        for (c of e.cells) {
            row = canvasgrid.data[c[0]];
            pk_value = row[pk_field];
            if (!sharedData[tname][pk_value]) sharedData[tname][pk_value] = {};
            f = schema[c[1]].name;
            sharedData[tname][pk_value][fields[f]] = [row[f], Date.now()];
        }
        uploadSharedData(tname);
    }

    function getBQToken() {
        fetch("https://us-central1-first-outlet-750.cloudfunctions.net/bqtoken")
        .then(res => res.json())
        .then(data => {bqtoken = data.Authorization;})
    }

    async function load() {
        setTimeout(init_firebase, 200);
        
        client_id = localStorage.getItem('client_id');
        if (!client_id) {
            client_id = Math.random().toString(36).substr(2);
            localStorage.setItem('client_id', client_id);
        }

        // await idb.deleteDB('DuckParquet');
        i_db = await idb.openDB('DuckParquet', 2, {
            upgrade(i_db) {
                // Create a store of objects
                i_db.createObjectStore('parquets');
            },
        });

        let qstatus = document.getElementById('query_status');
        qstatus.innerHTML = `<span>Initializing DuckDB ... </span>`;

        duckdb = await import(`https://cdn.skypack.dev/@duckdb/duckdb-wasm@${libraryVersion}`);
        bundle = await duckdb.selectBundle(DUCKDB_BUNDLES);

        // download worker script
        let workerReq = await fetch(bundle.mainWorker);
        let workerScript = await workerReq.text();
        let workerScriptBlob = new Blob([workerScript], { type: 'application/javascript' });
        workerURL = URL.createObjectURL(workerScriptBlob);

        let duckdb_version = localStorage.getItem('duckdb_version');
        console.log("duckdb_version", duckdb_version);

        let blob = 0;
        if (duckdb_version == libraryVersion) {
            const tx = i_db.transaction('parquets', 'readwrite');
            const store = tx.objectStore('parquets');
            blob = (await store.get('duckdb_wasm')) || 0;
            duckdb_wasmURL = URL.createObjectURL(blob);
            await tx.done;
        } else {
            // download WASM
            let wasmReq = await fetch(bundle.mainModule);
            let blob = await wasmReq.blob();
            duckdb_wasmURL = URL.createObjectURL(blob);

            const tx = i_db.transaction('parquets', 'readwrite');
            const store = tx.objectStore('parquets');
            await store.put(blob, 'duckdb_wasm');
            await tx.done;

            localStorage.setItem('duckdb_version', libraryVersion);
        }

        // download Wasm
        if (!bundle.pthreadWorker) {
            duckdb_pThreadURL = undefined;
        } else {
            let pthreadReq = await fetch(bundle.pthreadWorker);
            duckdb_pThreadURL = URL.createObjectURL(await pthreadReq.blob());
        }

        let instance;
        for (let i=0; i<3; i++) {
            instance = await make_duckdb();
            duck_dbs.push({
                instance: instance,
                in_using: false,
                running_main_query: false
            })
        }
        qstatus.innerHTML = "&nbsp;";
        document.title = `DuckDB - ${libraryVersion}`;
        getBQToken();
    }

    window.onload = function () { 
        load();
        sql_editer = CodeMirror.fromTextArea(document.getElementById('textarea_sql_editer'), {
            mode: "text/x-mysql",
            lineNumbers: true,
            indentWithTabs: true,
            smartIndent: true,
            lineNumbers: true,
            matchBrackets : true,
            autofocus: true,
            extraKeys: {
                "Ctrl-Space": "autocomplete",
                "Cmd-Enter":  function(cm) {
                    onClickPlay()
                },
                'Cmd-/': function(cm) {
                    sql_editer.execCommand('toggleComment')
                }
            },
            hintOptions: {tables: {
                users: {name: null, score: null, birthDate: null},
                countries: {name: null, population: null, size: null}
            }}
        });
        sql_parser = new NodeSQLParser.Parser();
        canvasgrid = canvasDatagrid({
                parentNode: document.getElementById('grid'),
                style: {
                    overflowX: 'hidden',
                    overflowY: 'hidden',
                }
            });

        canvasgrid.style.cellWidth = 120;
        // canvasgrid.style.cellFont = "14px";
        canvasgrid.style.height = '660px';
        canvasgrid.style.width = '100%';
        canvasgrid.addEventListener('beforebeginedit', onBeginEditTable);
        canvasgrid.addEventListener('beforeendedit', onEndEditTable);
        canvasgrid.addEventListener('afterpaste', onAfterPaste);
        canvasgrid.addEventListener('rendercell', onRenderCell);
        canvasgrid.addEventListener('click', onClickGrid);
    };

    window.onbeforeunload = function (event) {
        sendDataToFirebase('events/cursor/'+ client_id, null);

        // var message = 'Important: Please click on \'Save\' button to leave this page.';
        // if (typeof event == 'undefined') {
        //     event = window.event;
        // }
        // if (event) {
        //     event.returnValue = message;
        // }
        // return message;
    };

    function onClickGrid(e) {
        if (ctidx && e.cell.rowIndex !== undefined && e.cell.rowIndex != -1 && e.cell.columnIndex != -1) {
            if (e.cell.rowIndex != grid_active_rowIndex || e.cell.columnIndex != grid_active_columnIndex) {
                grid_active_rowIndex = e.cell.rowIndex;
                grid_active_columnIndex = e.cell.columnIndex;
                sendDataToFirebase('events/cursor/'+client_id, {
                    tableIndex: ctidx,
                    rowIndex: grid_active_rowIndex,
                    columnIndex: grid_active_columnIndex
                });
            }
        }
    }

    function onRenderCell(e) {
        if (ctidx && clients.cursors) {
            let i = 0;
            for (let k in clients.cursors) {
                if (k != client_id && clients.cursors[k].tableIndex == ctidx && e.cell.rowIndex == clients.cursors[k].rowIndex && e.cell.columnIndex == clients.cursors[k].columnIndex) {
                    e.ctx.fillStyle = CELL_COLORS[i % CELL_COLORS.length];
                }
                i++;
            }
        }
    }

    const qfile_input = document.getElementById("qfile");
    qfile_input.addEventListener("change", registerFile, false);
    async function registerFile() {
        let existTable = false;
        for (let i=0; i<internal_tables.length; i++) {
            if (internal_tables[i].file.name == this.files[0].name) {
                existTable = true;
                break;
            }
        }
        if (!existTable) {
            let new_data = {
                file: {
                    name: this.files[0].name,
                    size: this.files[0].size,
                    lastModified: this.files[0].lastModified,
                    hash: await hashwasm.md5(`${this.files[0].name}${this.files[0].size}${this.files[0].lastModified}`),
                    handle: this.files[0]
                },
                table: {
                    name: this.files[0].name.split('.')[0].toLowerCase(),
                    icon: TABLE_ICON_NONE
                },
            }
            internal_tables.push(new_data);
            refresh_tables();
            for(let i=0; i<duck_dbs.length; i++) {
                duck_dbs[i].instance.registerFileHandle(this.files[0].name, this.files[0]);
            }
            qtname = null;
            const preview_start_time = Date.now();
            const query = `SELECT * FROM '${this.files[0].name}' LIMIT 100`;
            const preview = await run_query(query, true);
            if (preview && canvasgrid.data.length > 0) {
                new_data.table.fields = Object.keys(canvasgrid.data[0]);
                for (f of new_data.table.fields) {
                    if (f.toLowerCase() == "id") {
                        new_data.table.pk = f;
                        break;
                    }
                }
            }

            new_data.table.preview = preview ? `Yes`: 'No';
            save_event_logs(EVENT_TYPE_FILE, `"${this.files[0].name}" Preview Generated - ${new_data.table.preview}`, preview_start_time, Date.now(), query);
            refresh_tables();

            setTimeout(create_localtable, 100, this.files[0].name);
        }
    }

    function create_localtable(file_name) {
        const table_name = file_name.split('.')[0].toLowerCase();
        for (let i=0; i<internal_tables.length; i++) {
            if (internal_tables[i].file.name == file_name) {
                const create_table_start_time = Date.now();
                const query = `CREATE TABLE IF NOT EXISTS '${table_name}' AS (SELECT * FROM '${file_name}')`;
                duck_dbs[0].in_using = true;
                run_only_query(duck_dbs[0].instance, query, true).then(async (res) => {
                    if (res) {
                        internal_tables[i].table.icon = TABLE_ICON_PREVIEW;
                        internal_tables[i].table.localtable = internal_tables[i].table.name;
                        save_event_logs(EVENT_TYPE_TABLE, `Created new local table (${table_name}) from "${file_name}"`, create_table_start_time, Date.now(), query);
                        refresh_tables();
                        sendDataToFirebase('duckdb/'+internal_tables[i].file.hash, internal_tables[i]);

                        // export_parquet(duck_dbs[0].instance, internal_tables[i]);
                    } else {
                        save_event_logs(EVENT_TYPE_TABLE, `Failed to create local table (${table_name}) from "${file_name}"`, create_table_start_time, Date.now(), query);
                        refresh_tables();
                    }
                    duck_dbs[0].in_using = false;
                })
                break;
            }
        }
    }

    function download_parquet(parquet_name, table_name) {
        // this.children[0].src = "/static/images/reload.gif";
        const starsRef = firestorage.ref(f_storage, parquet_name);
        firestorage.getDownloadURL(starsRef)
        .then(async (url) => {
            const res = await fetch(url);
            parquet_buffer[parquet_name] = new Uint8Array(await res.arrayBuffer());
            for (let i=0; i<duck_dbs.length; i++) {
                await duck_dbs[i].instance.registerFileBuffer(parquet_name, parquet_buffer[parquet_name]);
            }
            elapsed = (Date.now() - elapsed) / 1000;
            internal_tables[id].table.gcs_elapsed = `${elapsed.toFixed(2)}`;
            internal_tables[id].table.icon = TABLE_ICON_PREVIEW;
            refresh_tables();

            elapsed = Date.now();
            await run_only_query(duck_dbs[0].instance, `CREATE TABLE IF NOT EXISTS '${table_name}' AS (SELECT * FROM '${parquet_name}')`);
            elapsed = (Date.now() - elapsed) / 1000;
            internal_tables[id].table.localtable = `${table_name} (${elapsed.toFixed(2)}s)`;
            refresh_tables();
        })
        .catch((error) => {
            console.log(error);
        });
    }
    function onClickPreview() {
        ctidx = this.parentNode.parentNode.id;
        qtname = internal_tables[ctidx].table.name;
        if (selected_source[internal_tables[ctidx].file.hash] == "Remote BQTable") {
            run_bquery(`SELECT * FROM \`${projectId}.${tableId}.${internal_tables[ctidx].bqtable.name}\` LIMIT 100`, true);    
        } else {
            let query;
            switch (selected_source[internal_tables[ctidx].file.hash]) {
                case "Local Table": query = `SELECT * FROM '${internal_tables[ctidx].table.localtable}' LIMIT 100`; break;
                case "Local File": query = `SELECT * FROM '${internal_tables[ctidx].file.name}' LIMIT 100`; break;
                case "Local Parquet": query = `SELECT * FROM '${internal_tables[ctidx].parquet.name}' LIMIT 100`; break;
                case "Remote Parquet": query = `SELECT * FROM '${internal_tables[ctidx].parquet.remote}' LIMIT 100`; break;
            }
            if (query) run_query(query, true);
        }
        /*var select = document.getElementById("select_fields");
        while (select.hasChildNodes()) {
            select.removeChild(select.lastChild);
        }
        for (f of internal_tables[ctidx].table.fields) {
            if (f != internal_tables[ctidx].table.pk) {
                option = addCell(select, "option", f);
            }
        }*/
        refresh_tables(TID_FILES);
    }
    function onClickRemove() {
        const id = this.parentNode.parentNode.id;
        const start_time = Date.now();
        sendDataToFirebase('duckdb/'+ internal_tables[id].file.hash, null);
        save_event_logs(EVENT_TYPE_FILE, `Removed "${internal_tables[id].file.name}"`, start_time);
        internal_tables.splice(id, 1);
        refresh_tables();
    }

    function onClickDelete() {
        const id = this.parentNode.parentNode.id;
        const ttype = id.substr(0, 2);
        const tid = id.charAt(id.length-1);

        let message = "", res;
        switch(ttype) {
            case "LT": message = `Are you sure to delete Local Table "${internal_tables[tid].table.name}"?`; break;
            case "LP": message = `Are you sure to delete Local Parquet "${internal_tables[tid].parquet.name}"?`; break;
            case "RP": message = `Are you sure to delete Remote Parquet "${internal_tables[tid].parquet.remote}"?`; break;
            case "RT": message = `Are you sure to delete Remote Table "${internal_tables[tid].bqtable.name}"?`; break;
        }
        xdialog.confirm(message, async function() {
            const start_time = Date.now();
            switch(ttype) {
                case "LT":
                    res = await run_only_query(duck_dbs[0].instance, `DROP TABLE ${internal_tables[tid].table.name}`, true)
                    if (res) {
                        save_event_logs(EVENT_TYPE_FILE, `Removed Local Table "${internal_tables[tid].table.name}"`, start_time);
                        internal_tables[tid].table.localtable = "";
                    }
                    break;
                case "LP":
                    const tx = i_db.transaction('parquets', 'readwrite');
                    const store = tx.objectStore('parquets');
                    await store.delete(internal_tables[tid].file.hash);
                    await tx.done;
                    delete parquet_buffer[internal_tables[tid].parquet.name];
                    save_event_logs(EVENT_TYPE_FILE, `Removed Local Parquet "${internal_tables[tid].parquet.name}"`, start_time);
                    break;
                case "RP":
                    const storageRef = firestorage.ref(f_storage, internal_tables[tid].parquet.remote);
                    res = await firestorage.deleteObject(storageRef);
                    if (res === undefined) {
                        save_event_logs(EVENT_TYPE_FILE, `Remove Remote Parquet "${internal_tables[tid].parquet.remote}"`, start_time);
                        internal_tables[tid].parquet.remote = "";
                        sendDataToFirebase('duckdb/'+ internal_tables[tid].file.hash, internal_tables[tid]);
                    }
                    break;
                case "RT":
                    const bqdaemon = fireFuncs.httpsCallable(f_funcs, 'bqdaemon');
                    const result = await bqdaemon({command: "RemoveTable", tableId: internal_tables[tid].bqtable.name});
                    save_event_logs(EVENT_TYPE_FILE, `Remove Remote Parquet "${internal_tables[tid].bqtable.name}"`, start_time);
                    internal_tables[tid].bqtable.name = "";
                    sendDataToFirebase('duckdb/'+ internal_tables[tid].file.hash, internal_tables[tid]);
                    break;
            }
            refresh_tables(TID_FILES);
        }, {
            style: 'width:420px;font-size:0.8rem;',
            buttons: {
                ok: 'Yes',
                cancel: 'No'
            }
        });
    }
    function onClickDownload() {
        this.src = "/static/images/reload.gif";
        const id = this.parentNode.parentNode.id;
        const ttype = id.substr(0, 2);
        const tid = id.charAt(id.length-1);
        const starsRef = firestorage.ref(f_storage, internal_tables[tid].parquet.remote);
        let start_time = Date.now();
        firestorage.getDownloadURL(starsRef)
        .then(async (url) => {
            const res = await fetch(url);
            parquet_buffer[internal_tables[tid].parquet.name] = new Uint8Array(await res.arrayBuffer());
            for (let i=0; i<duck_dbs.length; i++) {
                await duck_dbs[i].instance.registerFileBuffer(internal_tables[tid].parquet.name, parquet_buffer[internal_tables[tid].parquet.name]);
            }
            save_event_logs(EVENT_TYPE_FILE, `Downloaded Remote Parquet "${internal_tables[tid].parquet.name}"`, start_time);
            if (ttype == "LT") {
                duck_dbs[0].in_using = true;
                start_time = Date.now();
                const res = await run_only_query(duck_dbs[0].instance, `CREATE TABLE IF NOT EXISTS '${internal_tables[tid].table.name}' AS (SELECT * FROM '${internal_tables[tid].parquet.name}')`);
                duck_dbs[0].in_using = false;
                if (res) {
                    internal_tables[tid].table.localtable = internal_tables[tid].table.name;
                    save_event_logs(EVENT_TYPE_FILE, `Created Local Table "${internal_tables[tid].table.localtable}"`, start_time);
                    refresh_tables(TID_FILES);
                }
            } else {
                refresh_tables();
            }

            const tx = i_db.transaction('parquets', 'readwrite');
            const store = tx.objectStore('parquets');

            await store.put(parquet_buffer[internal_tables[tid].parquet.name], internal_tables[tid].file.hash);
            await tx.done;
        })
        .catch((error) => {
            console.log(error);
        });
    }
    async function onClickUpload() {
        this.src = "/static/images/reload.gif";
        const id = this.parentNode.parentNode.id;
        const ttype = id.substr(0, 2);
        const tid = id.charAt(id.length-1);
        await export_parquet(duck_dbs[0].instance, internal_tables[tid]);
        upload_parquet(internal_tables[tid]);
    }
    async function onClickSync() {
        this.src = "/static/images/reload.gif";
        const id = this.parentNode.parentNode.id;
        const ttype = id.substr(0, 2);
        const tid = id.charAt(id.length-1);
        if (ttype == "LT") {
            if (internal_tables[tid].file.handle) {
                create_localtable(internal_tables[tid].file.name);
            } else if (internal_tables[tid].parquet && parquet_buffer[internal_tables[tid].parquet.name]) {
                duck_dbs[0].in_using = true;
                const start_time = Date.now();
                const res = await run_only_query(duck_dbs[0].instance, `CREATE TABLE IF NOT EXISTS '${internal_tables[tid].table.name}' AS (SELECT * FROM '${internal_tables[tid].parquet.name}')`);
                duck_dbs[0].in_using = false;
                if (res) {
                    internal_tables[tid].table.localtable = internal_tables[tid].table.name;
                    save_event_logs(EVENT_TYPE_FILE, `Created Local Table "${internal_tables[tid].table.localtable}"`, start_time);
                    refresh_tables(TID_FILES);
                }
            }
        } else if (ttype == "LP") {
            await export_parquet(duck_dbs[0].instance, internal_tables[tid]);
            refresh_tables(TID_FILES);
        }
    }

    async function save_logs(event_type, start_time, end_time, details, query='', refresh=true) {
        event_logs.push({
                type: EVENT_TYPES[event_type],
                start_time: start_time,
                end_time: end_time,
                duration: ((end_time - start_time) / 1000).toFixed(2),
                details: details,
            });
        if (refresh) refresh_tables(TID_LOGS);
    }

    async function save_event_logs(event_type, details, start_time=0, end_time=0, query='', refresh=true) {
        let event;
        if (start_time > 0) {
            if (end_time == 0) end_time = Date.now();
            const event_hash = await hashwasm.md5(`${event_type}${start_time}${end_time}${details}`);
            event = {
                type: EVENT_TYPES[event_type],
                start_time: start_time,
                end_time: end_time,
                duration: ((end_time - start_time) / 1000).toFixed(2),
                details: details,
                query: query,
                client_id: client_id
            };
            sendDataToFirebase('logs/'+event_hash, event);
            event.hash = event_hash
        } else {
            event = {
                type: EVENT_TYPES[event_type],
                start_time: start_time,
                end_time: end_time,
                duration: 0,
                details: details,
                query: query
            };
        }
        
        event_logs.push(event);

        if (refresh) refresh_tables(TID_LOGS);
    }

    function showTable(evt, tabName) {
        if (document.getElementById(tabName).style.display == "")
            document.getElementById(tabName).style.display = "none";
        else
            document.getElementById(tabName).style.display = "";
    }

    function select_one_source(t) {
        if (t.table.localtable) return "Local Table";
        if (t.file.handle) return "Local File";
        if (t.parquet && parquet_buffer[t.parquet.name]) return "Local Parquet";
        if (t.bqtable && t.bqtable.name) return "Remote BQTable";
        if (t.parquet && t.parquet.remote) return "Remote Parquet";
        return "";
    }

    function change_source() {
        selected_source[internal_tables[this.id].file.hash] = this.value;
    }

    function create_sources_dropdown(t, id, value) {
        let v = t.table.localtable || t.file.handle || (t.parquet && parquet_buffer[t.parquet.name]) || (t.bqtable && t.bqtable.name) || (t.parquet && t.parquet.remote);
        if (!v) return null;
        let td = document.createElement("td");
        let select = document.createElement("select"), option;
        select.onchange = change_source;
        select.id = id;
        td.appendChild(select);
        if (t.table.localtable) {
            option = addCell(select, "option", "Local Table");
            if (value == "Local Table") option.selected = "true";
        } 
        if (t.file.handle) {
            option = addCell(select, "option", "Local File");
            if (value == "Local File") option.selected = "true";
        } 
        if (t.parquet && parquet_buffer[t.parquet.name]) {
            option = addCell(select, "option", "Local Parquet");
            if (value == "Local Parquet") option.selected = "true";
        }
        if (t.bqtable && t.bqtable.name) {
            option = addCell(select, "option", "Remote BQTable");
            if (value == "Remote BQTable") option.selected = "true";
        }
        if (t.parquet && t.parquet.remote) {
            option = addCell(select, "option", "Remote Parquet");
            if (value == "Remote Parquet") option.selected = "true";
        }
        return td;
    }

    function save_primary_key() {
        const td = this.parentNode.parentNode;
        const tid = td.id.charAt(td.id.length-1);
        internal_tables[tid].table.pk = internal_tables[tid].table.new_pk;
        sendDataToFirebase('duckdb/'+internal_tables[tid].file.hash, internal_tables[tid]);
        td.removeChild(this.parentNode);
    }

    function change_primary_key() {
        const td = this.parentNode;
        internal_tables[td.id].table.new_pk = this.value;
        if (this.nextSibling) {
            if (internal_tables[td.id].table.pk == internal_tables[td.id].table.new_pk)
                td.removeChild(this.nextSibling);
            return;
        }
        var img = document.createElement('img'); 
        img.src = "/static/images/save.svg"; 
        img.style = "width: 16px; cursor: pointer;";
        img.onclick = save_primary_key;
        var span = document.createElement('span'); 
        span.appendChild(img);
        td.appendChild(span);
    }

    function create_fields_dropdown(t) {
        let td = document.createElement("td");
        if (t.table.fields) {
            let select = document.createElement("select"), option;
            td.appendChild(select);
            select.onchange = change_primary_key;
            addCell(select, "option", "");
            for (f of t.table.fields) {
                option = addCell(select, "option", f);
                if (f == t.table.pk) {
                    t.table.pk = f;
                    option.selected = "true";
                }
            }
        }
        return td;
    }

    function refresh_tables(tid = TID_ALL) {
        if (!ctidx && internal_tables.length > 0)
            ctidx = 0;
        if (tid == TID_ALL || tid == TID_FILES) {
            var tbody = document.getElementById(`${TID_FILES}_tbody`);
            while (tbody.hasChildNodes()) {
                tbody.removeChild(tbody.lastChild);
            }
            for (let k in internal_tables) {
                let t = internal_tables[k];
                let tr = document.createElement("tr");
                let src_flag = (t.parquet && parquet_buffer[t.parquet.name]) || (t.parquet && t.parquet.remote) || (t.bqtable && t.bqtable.name);
                let src = select_one_source(t);
                if (!selected_source[t.file.hash]) selected_source[t.file.hash] = src;
                if (src.length == 0) {
                    t.table.icon = TABLE_ICON_REMOVE;
                    delete selected_source[t.file.hash];
                }
                if (t.table.icon == TABLE_ICON_NONE) {
                    addCell(tr, "td");
                } else {
                    if (t.table.icon == TABLE_ICON_PREVIEW)
                        addCell(tr, "td", "", "", "", "/static/images/preview.svg", onClickPreview);
                    else
                        addCell(tr, "td", "", "", "", "/static/images/minus.svg", onClickRemove);
                }
                addCell(tr, "td", t.file.name);
                addCell(tr, "td", formatFileSize(t.file.size));
                addCell(tr, "td", new Date(t.file.lastModified).toDateString(), "", "cell_minwidh");
                addCell(tr, "td", t.table.name);
                // if (t.table.preview) addCell(tr, "td", t.table.preview); else addCell(tr, "td");
                if (t.table.localtable)
                    addCell(tr, "td","Yes", "LT"+k, "", "/static/images/delete.svg", onClickDelete);
                else {
                    if (t.file.handle || (t.parquet && parquet_buffer[t.parquet.name]))
                        addCell(tr, "td", "No ", "LT"+k, "", "/static/images/refresh.svg", onClickSync);
                    else if (src_flag)
                        addCell(tr, "td", "No ", "LT"+k, "", "/static/images/download.svg", onClickDownload);
                    else
                        addCell(tr, "td", "No");
                }
                if (t.parquet && parquet_buffer[t.parquet.name])
                    addCell(tr, "td", "Yes", "LP"+k, "", "/static/images/delete.svg", onClickDelete);
                else {
                    if (t.parquet && t.parquet.remote)
                        addCell(tr, "td", "No ", "LP"+k, "", "/static/images/download.svg", onClickDownload);
                    else if (t.table.localtable)
                        addCell(tr, "td", "No ", "LP"+k, "", "/static/images/refresh.svg", onClickSync);
                    else 
                        addCell(tr, "td", "No");
                }
                if (t.parquet && t.parquet.remote)
                    addCell(tr, "td", "Yes", "RP"+k, "", "/static/images/delete.svg", onClickDelete);
                else {
                    if (t.file.handle || (t.parquet && parquet_buffer[t.parquet.name]))
                        addCell(tr, "td", "No ", "RP"+k, "", "/static/images/upload.svg", onClickUpload);
                    else
                        addCell(tr, "td", "No");
                }
                if (t.bqtable && t.bqtable.name)
                    addCell(tr, "td", "Yes", "RT"+k, "", "/static/images/delete.svg", onClickDelete);
                else {
                    if (t.file.handle || (t.parquet && parquet_buffer[t.parquet.name]))
                        addCell(tr, "td", "No ", "RT"+k, "", "/static/images/upload.svg", onClickUpload);
                    else
                        addCell(tr, "td", "No");
                }

                let td = create_sources_dropdown(t, k, selected_source[t.file.hash]);
                if (td)
                    tr.appendChild(td);
                tr.id = k;
                if (k == ctidx) tr.classList.add('selected');
                // tr.onclick = onClickTable;
                tbody.appendChild(tr);
            }
            Sortable.initTable(document.getElementById(TID_FILES));
        }

        if (tid == TID_ALL || tid == TID_TABLES) {
            var tbody = document.getElementById(`${TID_TABLES}_tbody`);
            while (tbody.hasChildNodes()) {
                tbody.removeChild(tbody.lastChild);
            }
            for (let k in internal_tables) {
                let t = internal_tables[k];
                let tr = document.createElement("tr");
                addCell(tr, "td", parseInt(k)+1);
                addCell(tr, "td", t.table.name);
                td = create_fields_dropdown(t);
                td.id = k;
                tr.appendChild(td);
                if (t.parquet && parquet_buffer[t.parquet.name]) addCell(tr, "td", t.parquet.name); else addCell(tr, "td");
                if (t.parquet && t.parquet.remote) addCell(tr, "td", t.parquet.remote, "cell_overlay"); else addCell(tr, "td");
                if (t.bqtable && t.bqtable.name) addCell(tr, "td", t.bqtable.name); else addCell(tr, "td");
                tr.id = k;
                tbody.appendChild(tr);
            }
            Sortable.initTable(document.getElementById(TID_TABLES));
        }

        if (tid == TID_ALL || tid == TID_LOGS) {
            var tbody = document.getElementById(`${TID_LOGS}_tbody`);
            while (tbody.hasChildNodes()) {
                tbody.removeChild(tbody.lastChild);
            }
            for (let ev of event_logs) {
                let tr = document.createElement("tr");
                addCell(tr, "td", ev.type);
                if (ev.start_time > 0) {
                    addCell(tr, "td", ev.start_time);
                    addCell(tr, "td", ev.duration + "s");
                } else {
                    addCell(tr, "td", "-");
                    addCell(tr, "td", "-");
                }
                addCell(tr, "td", ev.details);
                tbody.appendChild(tr);
            }
            Sortable.initTable(document.getElementById(TID_LOGS));
        }
    }

    function onClickTable(e) {
        if (e.target.localName == 'td' && ctidx != e.currentTarget.id) {
            ctidx = parseInt(e.currentTarget.id);
            refresh_tables(TID_FILES);
        }
    }

    function onClickPlay() {
        cancel_query = false;
        qtname = null;

        let selected = sql_editer.getSelection();
        if (selected) {
            run_query(selected.replaceAll('#', '-- '));
            return;
        }

        let query = sql_editer.getValue();
        let ast, sql;
        query = query.replaceAll('#', '-- ');

        try {
            ast = sql_parser.astify(query);
            if (typeof(ast) == 'undefined' || typeof(ast.length) == 'undefined') {
                if (ast.type != null && ast.columns.length > 0) {
                    run_query(query);
                }
                return;
            } 
            if (ast.length == 1) {
                sql = sql_parser.sqlify(ast);
                run_query(sql);
                return;
            }
        } catch (e) {
            var qstatus = document.getElementById('query_status');
            qstatus.innerHTML = `<span class="error_code">${e.message}</span>`;
            return
        }

        let cursor = sql_editer.getCursor();
        if (cursor.line == 0) {
            sql = sql_parser.sqlify(ast[0]);
            run_query(sql);
            return;
        }

        queries = query.split('\n');
        query = ''
        for (let i=cursor.line-1; i>0; i--) { // scan up direction of current cursor
            line = queries[i].trim();
            if (line.startsWith("-- ") || line.startsWith("#"))
                continue;

            if (line.indexOf(";") > 0)
                break;

            if (line.length > 0)
                query = line + '\n' + query;
        }

        for (let i=cursor.line; i<queries.length; i++) { // scan down direction of current cursor
            line = queries[i].trim();
            if (line.startsWith("-- ") || line.startsWith("#"))
                continue;

            if (line.length > 0) {
                query += line + '\n';
                if (line.indexOf(";") > 0)
                   break;
            }
        }

        if (query) {
            ast = sql_parser.astify(query);
            if (typeof(ast) == 'undefined' || typeof(ast.length) == 'undefined') {
                if (ast.type != null && ast.columns.length > 0) {
                    run_query(query);
                }
                return;
            }
            
            sql = sql_parser.sqlify(ast);
            run_query(sql);
        }
    }

    async function reregister_files(db, create_localtable=false) {
        for (let t of internal_tables) {
            if (t.parquet && parquet_buffer[t.parquet.name]) {
                await db.registerFileBuffer(t.parquet.name, parquet_buffer[t.parquet.name]);
                if (create_localtable)
                    await run_only_query(db, `CREATE TABLE IF NOT EXISTS '${t.table.name}' AS (SELECT * FROM '${t.parquet.name}')`, preview=false)
            } else if (t.file.handle) {
                await db.registerFileHandle(t.file.name, t.file.handle);
                if (create_localtable && t.table && t.table.name)
                    await run_only_query(db, `CREATE TABLE IF NOT EXISTS '${t.table.name}' AS (SELECT * FROM '${t.file.name}')`, preview=false)
            }
        }
    }

    async function onClickCancel() {
        document.getElementById("loader").classList.remove("show_block");
        document.getElementById("cancel_button").classList.remove("show_block");

        canvasgrid.data = [];
        var qstatus = document.getElementById('query_status');
        qstatus.innerHTML = `<span class="error_code">Query was canceled </span>`;

        console.log('onClickCancel', first_result);

        cancel_query = true;
        if (!first_result) {
            for(let i=0; i<duck_dbs.length; i++) {
                if (duck_dbs[i].running_main_query) {
                    console.log('running_main_query', i)
                    duck_dbs[i].running_main_query = false;
                    await duck_dbs[i].instance.terminate();
                    duck_dbs[i].instance = await make_duckdb();
                    if (i == 0) 
                        await reregister_files(duck_dbs[i].instance, true);
                    else
                        await reregister_files(duck_dbs[i].instance, false);
                    duck_dbs[i].in_using = false;
                    break;
                }
            }
        }
    }

    function show_loader() {
        document.getElementById("loader").classList.add("show_block");
        document.getElementById("cancel_button").classList.add("show_block");
    }

    function check_bqtable(data) {
        const dbRef = firedb.ref(f_db);
        firedb.get(firedb.child(dbRef, 'duckdb/'+data.file.hash)).then((snapshot) => {
            const d = snapshot.val();
            if (d.bqtable && d.bqtable.name) {
                data.bqtable = d.bqtable;
                const end_time = Date.now();
                save_event_logs(EVENT_TYPE_FILE, `Created remote BQtable "${d.bqtable.name}" from remote parquet "${data.parquet.remote}"`, end_time-d.bqtable.bq_elapsed, end_time);
                refresh_tables();
            } else {
                setTimeout(check_bqtable, 2000, data);
            }
        });
    }

    function upload_parquet(data) {
        const storageRef = firestorage.ref(f_storage, `${data.file.hash}.parquet`);
        const start_time = Date.now();
        firestorage.uploadBytes(storageRef, parquet_buffer[data.parquet.name])
        .then((res) => {
            console.log(res);
            data.parquet.remote = `${data.file.hash}.parquet`;
            data.table.gcs_elapsed = ((Date.now() - start_time) / 1000).toFixed(2);
            save_event_logs(EVENT_TYPE_FILE, `Uploaded "${data.parquet.name}" to remote parquet "${data.parquet.remote}"`, start_time);
            refresh_tables();
            sendDataToFirebase('duckdb/'+data.file.hash, data);
            setTimeout(check_bqtable, 2000, data);
        })
        .catch((error) => {
            console.log(error);
        });
    }

    async function export_parquet(db, data) {
        try {
            let elapsed = Date.now();
            if (!data.parquet || !parquet_buffer[data.parquet.name]) {
                const conn = await db.connect();
                const query = `COPY ${data.table.name} TO '/tmp/${data.table.name}.parquet' (FORMAT 'PARQUET', CODEC 'GZIP')`;
                await conn.query(query);
                await conn.close();
                
                data.parquet = {
                    name: `${data.table.name}.parquet`,
                    elapsed: ((Date.now() - elapsed) / 1000).toFixed(2)
                }
                save_event_logs(EVENT_TYPE_FILE, `Exported parquet file "${data.parquet.name}"`, query, elapsed);
                refresh_tables();
                
                parquet_buffer[data.parquet.name] = await db.copyFileToBuffer(`/tmp/${data.parquet.name}`);
                
                sendDataToFirebase('duckdb/'+data.file.hash, data);
                
                const tx = i_db.transaction('parquets', 'readwrite');
                const store = tx.objectStore('parquets');

                await store.put(parquet_buffer[data.parquet.name], data.file.hash);
                await tx.done;
            }
            return true;
        } 
        catch (e) {
            console.log(e)
        }

        return false;
    } 

    async function run_only_query(db, query, preview=false) {
        try {
            const conn = await db.connect();
            await conn.query(query);
            await conn.close();

            return true;
        }
        catch (e) {
            var qstatus = document.getElementById('query_status');
            if (preview) {
                qstatus.innerHTML = `<span class="error_query">Can't create internal table.</span><br><span class="error_code">${e.message}</span>`;
            } else {
                qstatus.innerHTML = `<span class="error_code">${e.message}</span>`;
            }
        }

        return false;
    } 

    async function run_query(query, preview=false, save_log=true) {
        if (duck_dbs.length == 0)
            return false;

        first_result = false

        var tid = setTimeout(show_loader, 300);
        var qstatus = document.getElementById('query_status');
        qstatus.innerHTML = '<span class="elapsed">Running...</span>';

        var ret = false, data = [], conn, uindex;
        try {
            const start_time = Date.now();
            for(let i=0; i<duck_dbs.length; i++) {
                if (!duck_dbs[i].in_using) {
                    uindex = i;
                    console.log('uindex', uindex);
                    break;
                }
            }

            duck_dbs[uindex].in_using = true;
            duck_dbs[uindex].running_main_query = true;
            conn = await duck_dbs[uindex].instance.connect();

            if (uindex == 0) {
                for (let i=0; i<internal_tables.length; i++) {
                    if (internal_tables[i].table.name && query.indexOf(`"${internal_tables[i].file.name}"`) > 0) {
                        query = query.replaceAll(`"${internal_tables[i].file.name}"`, `"${internal_tables[i].table.name}"`);
                    }
                }
            } else {
                for (let i=0; i<internal_tables.length; i++) {
                    if (query.indexOf(`"${internal_tables[i].table.name}"`) > 0) {
                        query = query.replaceAll(`"${internal_tables[i].table.name}"`, `"${internal_tables[i].file.name}"`);
                    }
                }
            }

            const result = await conn.send(query);

            let batch = (await result.next()).value;
            const field_names = []
            for (let field of batch.schema.fields) {
                field_names.push(field.name)
            }
            first_result = true
            while(batch.length > 0 && !cancel_query) {
                for (let row of batch) {
                    let r = {}, pk_value = row[internal_tables[ctidx].table.pk];
                    for (let f of field_names) {
                        r[f] = row[f];
                        if (qtname && sharedData[qtname]) {
                            if (sharedData[qtname][pk_value] && sharedData[qtname][pk_value][sharedData[qtname]["fields"][f]])
                                r[f] = sharedData[qtname][pk_value][sharedData[qtname]["fields"][f]][0];
                        }
                    }
                    data.push(r)
                }
                if (cancel_query) break;
                batch = (await result.next()).value;
                if (!batch) break;
            }
            
            await conn.close();
            
            const end_time = Date.now();
            if (cancel_query) {
                qstatus.innerHTML = `<span class="error_code">Query was canceled </span>`;
            } else {
                if (preview) {
                    qstatus.innerHTML = `<span class="elapsed">Preview :</span><span>100 rows</span>`;
                } else {
                    let elapsed = end_time - start_time;
                    if (elapsed < 1000)
                        qstatus.innerHTML = `<span class="elapsed">Elapsed :</span><span>${elapsed} ms</span>`;
                    else {
                        elapsed = elapsed / 1000
                        qstatus.innerHTML = `<span class="elapsed">Elapsed :</span><span>${elapsed.toFixed(2)} s</span>`;
                    }
                }
            }

            if (save_log)
                save_event_logs(EVENT_TYPE_QUERY, query, start_time, end_time, query);
            ret = true;
        } 
        catch (e) {
            if (!preview) {
                qstatus.innerHTML = `<span class="error_code">${e.message}</span>`;
            }
            data = [];
        }

        clearTimeout(tid);
        
        duck_dbs[uindex].in_using = false;
        duck_dbs[uindex].running_main_query = false;

        document.getElementById("cancel_button").classList.remove("show_block");
        document.getElementById("loader").classList.remove("show_block");
        if (cancel_query)
            canvasgrid.data = [];
        else
            canvasgrid.data = data;

        return ret;
    }

    async function run_bquery(query, preview=false) {
        document.getElementById("loader").classList.add("show_block");
        var qstatus = document.getElementById('query_status');
        qstatus.innerHTML = '<span class="elapsed">Running...</span>';
        
        const start_time = Date.now();
        try {
            const res = await fetch(BQUERY_URL, {
                                        method: 'POST',
                                        headers: {"authorization": bqtoken, 'Content-Type': 'application/json'},
                                        body: JSON.stringify({
                                            "query": query,
                                            "useLegacySql":false 
                                    })});
            
            if (res.ok) {
                const result = await res.json();
                const end_time = Date.now();
                let data = []
                if (result.schema && result.rows) {
                    for (row of result.rows) {
                        const fieldObject = {};
                        for (index in row.f) {
                            fieldObject[result.schema.fields[index].name] = row.f[index].v;
                        }
                        data.push(fieldObject);
                    }
                    if (preview) {
                        qstatus.innerHTML = `<span class="elapsed">Preview :</span><span>100 rows</span>`;
                    } else {
                        const elapsed = end_time - start_time;
                        if (elapsed < 1000)
                            qstatus.innerHTML = `<span class="elapsed">Elapsed :</span><span>${elapsed} ms</span>`;
                        else {
                            elapsed = elapsed / 1000
                            qstatus.innerHTML = `<span class="elapsed">Elapsed :</span><span>${elapsed.toFixed(2)} s</span>`;
                        }
                    }
                }
                canvasgrid.data = data;
                save_event_logs(EVENT_TYPE_QUERY, `Run bquery`, start_time, end_time, query);
                update_canvasgrid();
            }
        } catch (e) {
            qstatus.innerHTML = `<span class="error_code">${e.message}</span>`;
        }

        document.getElementById("loader").classList.remove("show_block");
    }

    async function mount_duckdb_dir() {
        const out = {};
        const dirHandle = await showDirectoryPicker(); 
        const parquet_handle = await dirHandle.getDirectoryHandle( 'parquets', { create: true } );

        await handleDirectoryEntry( dirHandle, out );
        console.log( out );
    }

    function update_canvasgrid() {
        if (ctidx && sharedData[internal_tables[ctidx].table.name]) {
            const tname = internal_tables[ctidx].table.name, pk_field = internal_tables[ctidx].table.pk;
            for (let i=0; i<canvasgrid.data.length; i++) {
                let pk_value = canvasgrid.data[i][pk_field];
                for (let f in canvasgrid.data[i]) {
                    if (tname && sharedData[tname]) {
                        if (sharedData[tname][pk_value] && sharedData[tname][pk_value][sharedData[tname]["fields"][f]])
                            canvasgrid.data[i][f] = sharedData[tname][pk_value][sharedData[tname]["fields"][f]][0];
                    }
                }
            }
            canvasgrid.draw();
        }
    }

    function initSharedData(tablename) {
        if (!sharedData[tablename]) sharedData[tablename] = {};
        if (!sharedData[tablename]["fields"]) {
            sharedData[tablename]["fields"] = {}
            for (let t of internal_tables) {
                if (t.table.name == tablename) {
                    for (let i=0; i<t.table.fields.length; i++)
                        sharedData[tablename]["fields"][t.table.fields[i]] = i;
                    break;
                }
            }
        }
    }

    async function change_table() {
        if (ctidx) {
            document.getElementById("loader").classList.add("show_block");

            const select_field = document.getElementById("select_fields").value;
            const field_value = document.getElementById("txt_field_value").value;

            const conn = await duck_dbs[0].instance.connect();
            const query = `SELECT * FROM \"${internal_tables[ctidx].parquet.name}\"`;
            const result = await conn.send(query);

            let batch = (await result.next()).value;
            const field_names = []
            for (let field of batch.schema.fields) {
                field_names.push(field.name)
            }

            const data = [];
            const tname = internal_tables[ctidx].table.name;
            
            initSharedData(tname);
            
            const fields = sharedData[tname]["fields"], pk_field = internal_tables[ctidx].table.pk;
            while (batch.length > 0) {
                for (let row of batch) {
                    let r = {};
                    for (let f of field_names) {
                        if (f == select_field) {
                            r[f] = field_value;
                        } else {
                            r[f] = row[f];
                        }
                    }
                    data.push(r);
                    let pk_value = r[pk_field];
                    if (!sharedData[tname][pk_value]) sharedData[tname][pk_value] = {};
                    sharedData[tname][pk_value][fields[select_field]] = [field_value, Date.now()];
                }
                batch = (await result.next()).value;
                if (!batch) break;
            }
            await conn.close();
            canvasgrid.data = data;
            document.getElementById("loader").classList.remove("show_block");
            uploadSharedData(tname);
        }
    }

    async function uploadSharedData(tname) {
        if (navigator.onLine) {
            const data = btoa(pako.deflate(JSON.stringify(sharedData), { to: 'string' }));
            sendDataToFirebase(`events/offline_update/`+client_id, data);
            pending_tables[tname] = false;
        } else {
            pending_tables[tname] = true;
        }
    }

    // A function is used for dragging and moving
    function dragElement(element, direction)
    {
        var   md; // remember mouse down info
        const first  = document.getElementById("first");
        const second = document.getElementById("second");

        element.onmousedown = onMouseDown;

        function onMouseDown(e)
        {
            //console.log("mouse down: " + e.clientX);
            md = {  
                    e,
                    offsetLeft:  element.offsetLeft,
                    offsetTop:   element.offsetTop,
                    firstWidth:  first.offsetWidth,
                    secondWidth: second.offsetWidth
                };

            document.onmousemove = onMouseMove;
            document.onmouseup = () => {
                //console.log("mouse up");
                document.onmousemove = document.onmouseup = null;
                window.dispatchEvent(new Event('resize'));
            }
        }

        function onMouseMove(e)
        {
            //console.log("mouse move: " + e.clientX);
            var delta = {x: e.clientX - md.e.clientX,
                        y: e.clientY - md.e.clientY};

            if (direction === "H" ) // Horizontal
            {
                // Prevent negative-sized elements
                delta.x = Math.min(Math.max(delta.x, -md.firstWidth),
                        md.secondWidth);

                element.style.left = md.offsetLeft + delta.x + "px";
                first.style.width = (md.firstWidth + delta.x) + "px";
                second.style.width = (md.secondWidth - delta.x) + "px";
            }
        }
    }
    dragElement( document.getElementById("separator"), "H" );
</script>
</html>