<!DOCTYPE html>
<html>
<head>
    <title>DuckDB</title>
    <link rel="stylesheet" href="http://codemirror.net/lib/codemirror.css">
    <link rel="stylesheet" href="http://codemirror.net/addon/hint/show-hint.css">
    <link rel="stylesheet" href="./static/css/sortable-theme-bootstrap.css" />
    <link rel="stylesheet" href="./static/css/styles.css" />
    
    <script src="http://codemirror.net/lib/codemirror.js"></script>
    <script src="http://codemirror.net/addon/edit/matchbrackets.js"></script>
    <script src="http://codemirror.net/mode/sql/sql.js"></script>
    <script src="http://codemirror.net/addon/hint/show-hint.js"></script>
    <script src="http://codemirror.net/addon/hint/sql-hint.js"></script>
    <script src="http://codemirror.net/addon/comment/comment.js"></script>
    <script src="http://pure.github.io/pure/libs/pure.js"></script>
    <script src="https://unpkg.com/canvas-datagrid"></script>
    <script src="./static/js/pg_query.js"></script>
    <script src="./static/js/sortable.js"></script>
    <script src="./static/js/pgsql_parser.js"></script>
    <script src="./static/js/script.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@6.1.5/build/iife/with-async-ittr-min.js"></script>
    <!-- <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script> -->
    <!-- <script src="./static/js/localforage.js"></script> -->
</head>

<body>
<div>
    <h3>SQL Editer</h3>
    <div class="sql_editer_container">
        <div class="left_panel">
            <div style="float: left;">
                <button type="button" class="btn" onclick="onClickPlay()"><img src="/static/images/play.svg" style="width: 15px; margin: 0;"></button>
                <br><br>
                <button type="button" class="btn tooltip hidden" onclick="onClickCancel()" id="cancel_button">
                    <img src="/static/images/cancel.svg" style="width: 15px; margin: 0;">
                    <span class="tooltiptext tooltip-right">If click this button, the query will be stopped right away and initialized database</span>
                </button>
            </div>
            <textarea rows="4" cols="50" name="textarea_sql_editer" id="textarea_sql_editer">
    # Use '--' or '#' for comments.
    -- space needed after '--'
    -- use semicolon (;) at the end of multiline query

    SELECT 1 AS "Result"
        UNION SELECT 2
        UNION SELECT 3;
            </textarea>
        </div>
        <div class="right_panel">
            <div class="loader" id="pageloader">
                <div class="inner one"></div>
                <div class="inner two"></div>
                <div class="inner three"></div>
            </div>
            <div class="hidden" id="tab_container">
                <div class="tab">
                    <button class="tablinks" onclick="openTabs(event, 't_files')">Files</button>
                    <button class="tablinks" onclick="openTabs(event, 't_tables')">Tables</button>
                    <button class="tablinks" onclick="openTabs(event, 't_logs')">Logs</button>
                </div>
                <div id="t_files" class="tabcontent">
                    <table class="sortable-theme-bootstrap" data-sortable name="t_files_st" id="t_files_st">
                        <thead id="thead">
                            <tr>
                                <th></th>
                                <th>Name</th>
                                <th>Size</th>
                                <th>Last Modified</th>
                                <th>Preview Generated?</th>
                                <th>LocalTableName</th>
                                <th>LocalManaged ParquetFile</th>
                                <th>RemoteManaged ParquetFile</th>
                                <th>RemoteManaged BQTable</th>
                            </tr>
                        </thead>
                        <tbody id="t_files_st_tbody">
                        </tbody>
                    </table>
                </div>
                <div id="t_tables" class="tabcontent">
                    <table class="sortable-theme-bootstrap" data-sortable name="t_tables_st" id="t_tables_st">
                        <thead id="thead">
                            <tr>
                                <th></th>
                                <th>Name</th>
                                <th>LocalManagedParquetFile</th>
                                <th>RemoteManagedParquetFile</th>
                                <th>RemoteManagedBQTable</th>
                            </tr>
                        </thead>
                        <tbody id="t_tables_st_tbody">
                        </tbody>
                    </table>
                </div>
                <div id="t_logs" class="tabcontent">
                    <table class="sortable-theme-bootstrap" data-sortable name="t_logs_st" id="t_logs_st">
                        <thead id="thead">
                            <tr>
                                <th></th>
                                <th>EventType</th>
                                <th>Timestamp</th>
                                <th>Duration</th>
                                <th>Text</th>
                            </tr>
                        </thead>
                        <tbody id="t_logs_st_tbody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <div class="loader" id="loader">
        <div class="inner one"></div>
        <div class="inner two"></div>
        <div class="inner three"></div>
    </div>
    <div class="file_browser_container">
        <!-- <label for="file-input">
            <img src="/static/images/upload.svg" style="width: 30px;"/>
        </label>
        <input id="file-input" type="file" /> -->
        <label for="qfile">Select files:</label>
        <input type="file" id="qfile" name="qfile" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
        <!-- <button onclick="mount_duckdb_dir()">Mount DuckDB Directory</button> -->
    </div>
    <div id="query_status"></div>
    <div id="grid"></div>
</div>

<script type="module">
    // Import the functions you need from the SDKs you need
    const firebaseConfig = {
        apiKey: "apiKey",
        authDomain: "authDomain",
        projectId: "projectId",
        storageBucket: "storageBucket",
        messagingSenderId: "messagingSenderId",
        appId: "appId"
    };
    
    const firebase = await import(`https://www.gstatic.com/firebasejs/9.4.0/firebase-app.js`);
    window.firebaseApp = firebase.initializeApp(firebaseConfig);
    window.firestorage = await import(`https://www.gstatic.com/firebasejs/9.4.0/firebase-storage.js`);
    window.firedb = await import(`https://www.gstatic.com/firebasejs/9.4.0/firebase-database.js`);
</script>

<script>
    const libraryVersion = "0.1.12-dev89.0";
    const distURL = `https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@${libraryVersion}/dist/`;
    const TABLE_ICON_NONE = 0, TABLE_ICON_PREVIEW = 1, TABLE_ICON_REFRESH = 2;
    var duck_dbs = [], duckdb_wasmURL, duckdb_pThreadURL;
    var sql_editer, sql_parser;
    var canvasgrid;
    var cancel_query = false, first_result = false;
    var internal_tables = [], parquet_buffer = {};
    var current_tab;
    var f_storage, f_db, i_db;
  
    DUCKDB_BUNDLES = ({
        asyncDefault: {
            mainModule: new URL('duckdb.wasm', distURL).toString(),
            mainWorker: new URL('duckdb-browser-async.worker.js', distURL).toString(),
        },
        asyncNext: {
            mainModule: new URL(`duckdb-next.wasm`, distURL).toString(),
            mainWorker: new URL('duckdb-browser-async-next.worker.js', distURL).toString(),
        },
        asyncNextCOI: {
            mainModule: new URL('duckdb-next-coi.wasm', distURL).toString(),
            mainWorker: new URL('duckdb-browser-async-next-coi.worker.js', distURL).toString(),
            pthreadWorker: new URL('duckdb-browser-async-next-coi.pthread.worker.js', distURL).toString(),
        },
    })

    async function make_duckdb() {
        const logger = new duckdb.ConsoleLogger();
        const worker = new Worker(workerURL);
        const db = new duckdb.AsyncDuckDB(logger, worker);
        await db.instantiate(duckdb_wasmURL, duckdb_pThreadURL);
        console.log(db.getVersion());

        return db;
    }

    async function init_firedb() {
        const dbRef = firedb.ref(f_db);
        try {
            const snapshot = await firedb.get(firedb.child(dbRef, 'duckdb'));
            document.getElementById("pageloader").classList.remove("show_block");
            document.getElementById("tab_container").classList.remove("hidden");

            if (snapshot.exists()) {
                data = snapshot.val()
                for (k in data) {
                    const tx = i_db.transaction('parquets', 'readwrite');
                    const store = tx.objectStore('parquets');
                    let parquetbuff = (await store.get(data[k].file.hash)) || 0;
                    if (parquetbuff) {
                        let parquet_name = data[k].parquet.name
                        parquet_buffer[parquet_name] = parquetbuff;
                        for (let i=0; i<duck_dbs.length; i++) {
                            await duck_dbs[i].instance.registerFileBuffer(parquet_name, parquetbuff);
                        }
                        await run_only_query(duck_dbs[0].instance, `CREATE TABLE IF NOT EXISTS '${data[k].table.name}' AS (SELECT * FROM '${parquet_name}')`);
                        data[k].table.icon = TABLE_ICON_PREVIEW;
                    } else {
                        data[k].table.icon = TABLE_ICON_REFRESH;
                        // data[k].table.preview = '';
                        data[k].table.localtable = '';
                        data[k].table.gcs_elapsed = '';
                        data[k].parquet.elapsed = '';
                    }
                    internal_tables.push(data[k]);
                }
            } else {
                console.log("No data available");
            }
            return true;
        } catch (e) {
            return false;
        }
    }

    async function load() {
        document.getElementById("pageloader").classList.add("show_block");

        // await idb.deleteDB('DuckParquet');
        i_db = await idb.openDB('DuckParquet', 2, {
            upgrade(i_db) {
                // Create a store of objects
                i_db.createObjectStore('parquets');
            },
        });

        duckdb = await import(`https://cdn.skypack.dev/@duckdb/duckdb-wasm@${libraryVersion}`);
        bundle = await duckdb.selectBundle(DUCKDB_BUNDLES);

        // download worker script
        let workerReq = await fetch(bundle.mainWorker);
        let workerScript = await workerReq.text();
        let workerScriptBlob = new Blob([workerScript], { type: 'application/javascript' });
        workerURL = URL.createObjectURL(workerScriptBlob);

        let duckdb_version = localStorage.getItem('duckdb_version');
        let blob = 0;
        if (duckdb_version == libraryVersion) {
            const tx = i_db.transaction('parquets', 'readwrite');
            const store = tx.objectStore('parquets');
            blob = (await store.get('duckdb_wasm')) || 0;
            duckdb_wasmURL = URL.createObjectURL(blob);
            await tx.done;
        } else {
            // download WASM
            let wasmReq = await fetch(bundle.mainModule);
            let blob = await wasmReq.blob();
            duckdb_wasmURL = URL.createObjectURL(blob);

            const tx = i_db.transaction('parquets', 'readwrite');
            const store = tx.objectStore('parquets');
            await store.put(blob, 'duckdb_wasm');
            await tx.done;

            localStorage.setItem('duckdb_version', libraryVersion);
        }

        // download Wasm
        if (!bundle.pthreadWorker) {
            duckdb_pThreadURL = undefined;
        } else {
            let pthreadReq = await fetch(bundle.pthreadWorker);
            duckdb_pThreadURL = URL.createObjectURL(await pthreadReq.blob());
        }

        var instance;
        for (var i=0; i<3; i++) {
            instance = await make_duckdb();
            duck_dbs.push({
                instance: instance,
                in_using: false,
                running_main_query: false
            })
        }

        f_storage = firestorage.getStorage(firebaseApp);
        f_db = firedb.getDatabase(firebaseApp);

        await init_firedb();
    }

    window.onload = function () { 
        sql_editer = CodeMirror.fromTextArea(document.getElementById('textarea_sql_editer'), {
            mode: "text/x-mysql",
            lineNumbers: true,
            indentWithTabs: true,
            smartIndent: true,
            lineNumbers: true,
            matchBrackets : true,
            autofocus: true,
            extraKeys: {
                "Ctrl-Space": "autocomplete",
                "Cmd-Enter":  function(cm) {
                    onClickPlay()
                },
                'Cmd-/': function(cm) {
                    sql_editer.execCommand('toggleComment')
                }
            },
            hintOptions: {tables: {
                users: {name: null, score: null, birthDate: null},
                countries: {name: null, population: null, size: null}
            }}
        });
        sql_parser = new NodeSQLParser.Parser();
        canvasgrid = canvasDatagrid({
                parentNode: document.getElementById('grid'),
                style: {
                    overflowX: 'hidden',
                    overflowY: 'hidden',
                }
            });

        canvasgrid.style.cellWidth = 150;
        canvasgrid.style.height = '500px';
        canvasgrid.style.width = '100%';

        load();
    };

    const qfile_input = document.getElementById("qfile");
    qfile_input.addEventListener("change", registerFile, false);
    async function registerFile() {
        let existTable = false
        for (let i=0; i<internal_tables.length; i++) {
            if (internal_tables[i].file.name == this.files[0].name) {
                existTable = true;
                break;
            }
        }
        if (!existTable) {
            internal_tables.push({
                file: {
                    name: this.files[0].name,
                    size: this.files[0].size,
                    lastModified: this.files[0].lastModified,
                    handle: this.files[0]
                },
                table: {
                    icon: TABLE_ICON_NONE
                },
            });
            refresh_tables();
            for(let i=0; i<duck_dbs.length; i++) {
                duck_dbs[i].instance.registerFileHandle(this.files[0].name, this.files[0]);
            }
            preview_time = Date.now()
            let preview = await run_query(`SELECT * FROM '${this.files[0].name}' LIMIT 100`, true);
            setTimeout(background_process(this.files[0].name, preview, (Date.now()-preview_time)/1000), 100);
        }
    }

    function background_process(file_name, preview, elapsed) {
        const table_name = file_name.split('.')[0].toLowerCase();
        for (let i=0; i<internal_tables.length; i++) {
            if (internal_tables[i].file.name == file_name) {
                internal_tables[i].table.preview = preview ? `Yes (${elapsed.toFixed(2)}s)`: 'No';
                refresh_tables();

                elapsed = Date.now()
                duck_dbs[0].in_using = true;
                run_only_query(duck_dbs[0].instance, `CREATE TABLE IF NOT EXISTS '${table_name}' AS (SELECT * FROM '${file_name}')`, true).then(async (res) => {
                    if (res) {
                        elapsed = (Date.now() - elapsed) / 1000
                        internal_tables[i].table.icon = TABLE_ICON_PREVIEW;
                        internal_tables[i].table.name = table_name;
                        internal_tables[i].table.localtable = `${table_name} (${elapsed.toFixed(2)}s)`;
                        internal_tables[i].file.hash =  await hashwasm.md5(`${internal_tables[i].file.name}${internal_tables[i].file.size}${internal_tables[i].file.lastModified}`);
                        refresh_tables();
                        export_parquet(duck_dbs[0].instance, internal_tables[i])
                    }
                    duck_dbs[0].in_using = false;
                })
                break;
            }
        }
    }

    function onClickPreview() {
        const id = this.parentNode.id;
        const parquet_name = internal_tables[id].parquet.name;
        const table_name = internal_tables[id].table.name;
        let elapsed = Date.now();
        if (parquet_buffer[parquet_name]) {
            run_query(`SELECT * FROM '${parquet_name}' LIMIT 100`, true);
        } else {
            this.children[0].src = "/static/images/reload.gif";
            const starsRef = firestorage.ref(f_storage, parquet_name);
            firestorage.getDownloadURL(starsRef)
            .then(async (url) => {
                const res = await fetch(url);
                parquet_buffer[parquet_name] = new Uint8Array(await res.arrayBuffer());
                for (let i=0; i<duck_dbs.length; i++) {
                    await duck_dbs[i].instance.registerFileBuffer(parquet_name, parquet_buffer[parquet_name]);
                }
                elapsed = (Date.now() - elapsed) / 1000;
                internal_tables[id].table.gcs_elapsed = `${elapsed.toFixed(2)}`;
                internal_tables[id].table.icon = TABLE_ICON_PREVIEW;
                refresh_tables();

                elapsed = Date.now();
                await run_only_query(duck_dbs[0].instance, `CREATE TABLE IF NOT EXISTS '${table_name}' AS (SELECT * FROM '${parquet_name}')`);
                elapsed = (Date.now() - elapsed) / 1000;
                internal_tables[id].table.localtable = `${table_name} (${elapsed.toFixed(2)}s)`;
                refresh_tables();
            })
            .catch((error) => {
                console.log(error);
            });
        }
    }
    
    function openTabs(evt, tabName) {
        let i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
        current_tab = tabName;
        refresh_tables();
    }

    function refresh_tables() {
        if (!current_tab)
            return;

        var tbody = document.getElementById(`${current_tab}_st_tbody`);

        while (tbody.hasChildNodes()) {
            tbody.removeChild(tbody.lastChild);
        }

        for (let k in internal_tables) {
            let t = internal_tables[k];
            if (current_tab == "t_files") {
                let tr = document.createElement("tr");
                if (t.table.icon == TABLE_ICON_NONE) {
                    addCell(tr, "td", "");
                } else {
                    if (t.table.icon == TABLE_ICON_PREVIEW)
                        addCell(tr, "td", "", onClickPreview, "/static/images/preview.svg");
                    else
                        addCell(tr, "td", "", onClickPreview, "/static/images/refresh.svg");
                }
                addCell(tr, "td", t.file.name);
                addCell(tr, "td", t.file.size);
                addCell(tr, "td", new Date(t.file.lastModified).toUTCString());
                if (t.table.preview) addCell(tr, "td", t.table.preview);
                if (t.table.name) addCell(tr, "td", t.table.name);
                if (t.parquet && parquet_buffer[t.parquet.name]) addCell(tr, "td", t.table.name);
                if (t.parquet && parquet_buffer[t.parquet.name]) addCell(tr, "td", t.table.name);
                if (t.table.bqname) addCell(tr, "td", t.table.bqname);
                tr.id = k;
                tbody.appendChild(tr);
            } else if (current_tab == "t_tables") {
                let tr = document.createElement("tr");
                addCell(tr, "td", k);
                if (t.table.name) addCell(tr, "td", t.table.name);
                if (t.parquet && parquet_buffer[t.parquet.name]) addCell(tr, "td", t.table.name);
                if (t.parquet && parquet_buffer[t.parquet.name]) addCell(tr, "td", t.table.name);
                if (t.table.bqname) addCell(tr, "td", t.table.bqname);
                tr.id = k;
                tbody.appendChild(tr);
            } else {
                let tr = document.createElement("tr");
            }
        }

        Sortable.initTable(document.getElementById(current_tab))
    }

    function onClickPlay() {
        cancel_query = false;

        let selected = sql_editer.getSelection();
        if (selected) {
            run_query(selected.replaceAll('#', '-- '));
            return;
        }

        let query = sql_editer.getValue();
        let ast, sql;
        query = query.replaceAll('#', '-- ');

        try {
            ast = sql_parser.astify(query);
            if (typeof(ast) == 'undefined' || typeof(ast.length) == 'undefined') {
                if (ast.type != null && ast.columns.length > 0) {
                    run_query(query);
                }
                return;
            } 
            if (ast.length == 1) {
                sql = sql_parser.sqlify(ast);
                run_query(sql);
                return;
            }
        } catch (e) {
            var qstatus = document.getElementById('query_status');
            qstatus.innerHTML = `<span class="error_code">${e.message}</span>`;
            return
        }

        let cursor = sql_editer.getCursor();
        if (cursor.line == 0) {
            sql = sql_parser.sqlify(ast[0]);
            run_query(sql);
            return;
        }

        queries = query.split('\n');
        query = ''
        for (let i=cursor.line-1; i>0; i--) { // scan up direction of current cursor
            line = queries[i].trim();
            if (line.startsWith("-- ") || line.startsWith("#"))
                continue;

            if (line.indexOf(";") > 0)
                break;

            if (line.length > 0)
                query = line + '\n' + query;
        }

        for (let i=cursor.line; i<queries.length; i++) { // scan down direction of current cursor
            line = queries[i].trim();
            if (line.startsWith("-- ") || line.startsWith("#"))
                continue;

            if (line.length > 0) {
                query += line + '\n';
                if (line.indexOf(";") > 0)
                   break;
            }
        }

        if (query) {
            ast = sql_parser.astify(query);
            if (typeof(ast) == 'undefined' || typeof(ast.length) == 'undefined') {
                if (ast.type != null && ast.columns.length > 0) {
                    run_query(query);
                }
                return;
            }
            
            sql = sql_parser.sqlify(ast);
            run_query(sql);
        }
    }

    async function reregister_files(db, create_localtable=false) {
        for (let t of internal_tables) {
            if (t.parquet && parquet_buffer[t.parquet.name]) {
                await db.registerFileBuffer(t.parquet.name, parquet_buffer[t.parquet.name]);
                if (create_localtable)
                    await run_only_query(db, `CREATE TABLE IF NOT EXISTS '${t.table.name}' AS (SELECT * FROM '${t.parquet.name}')`, preview=false)
            } else if (t.file.handle) {
                await db.registerFileHandle(t.file.name, t.file.handle);
                if (create_localtable && t.table && t.table.name)
                    await run_only_query(db, `CREATE TABLE IF NOT EXISTS '${t.table.name}' AS (SELECT * FROM '${t.file.name}')`, preview=false)
            }
        }
    }

    async function onClickCancel() {
        document.getElementById("loader").classList.remove("show_block");
        document.getElementById("cancel_button").classList.remove("show_block");

        canvasgrid.data = [];
        var qstatus = document.getElementById('query_status');
        qstatus.innerHTML = `<span class="error_code">Query was canceled </span>`;

        console.log('onClickCancel', first_result);

        cancel_query = true;
        if (!first_result) {
            for(let i=0; i<duck_dbs.length; i++) {
                if (duck_dbs[i].running_main_query) {
                    console.log('running_main_query', i)
                    duck_dbs[i].running_main_query = false;
                    await duck_dbs[i].instance.terminate();
                    duck_dbs[i].instance = await make_duckdb();
                    if (i == 0) 
                        await reregister_files(duck_dbs[i].instance, true);
                    else
                        await reregister_files(duck_dbs[i].instance, false);
                    duck_dbs[i].in_using = false;
                    break;
                }
            }
        }
    }

    function show_loader() {
        document.getElementById("loader").classList.add("show_block");
        document.getElementById("cancel_button").classList.add("show_block");
    }

    async function export_parquet(db, data) {
        try {
            const conn = await db.connect();
            const results = await db.globFiles('/tmp/*');

            let elapsed = Date.now();
            await conn.query(`COPY ${data.table.name} TO '/tmp/${data.table.name}.parquet' (FORMAT 'PARQUET', CODEC 'GZIP')`);
            const buff = await db.copyFileToBuffer(`/tmp/${data.table.name}.parquet`);
            await conn.close();

            data.parquet = {
                name: `${data.table.name}.parquet`,
                elapsed: ((Date.now() - elapsed) / 1000).toFixed(2)
            }

            parquet_buffer[data.parquet.name] = buff;

            let dict = internal_tables.reduce((a, x) => ({...a, [x.file.hash]: x}), {})
            firedb.set(firedb.ref(f_db, 'duckdb'), dict);

            //upload firebase storage
            const storageRef = firestorage.ref(f_storage, data.parquet.name);
            elapsed = Date.now();
            firestorage.uploadBytes(storageRef, buff)
            .then((res) => {
                data.table.gcs_elapsed = ((Date.now() - elapsed) / 1000).toFixed(2);
                refresh_tables();
                let dict = internal_tables.reduce((a, x) => ({...a, [x.file.hash]: x}), {})
                firedb.set(firedb.ref(f_db, 'duckdb'), dict);
            })
            .catch((error) => {
                console.log(error);
            });

            const tx = i_db.transaction('parquets', 'readwrite');
            const store = tx.objectStore('parquets');

            await store.put(buff, data.file.hash);
            await tx.done;

            return true;
        } 
        catch (e) {
            console.log(e)
        }

        return false;
    } 

    async function run_only_query(db, query, preview=false) {
        try {
            const conn = await db.connect();
            await conn.query(query);
            await conn.close();

            return true;
        } 
        catch (e) {
            var qstatus = document.getElementById('query_status');
            if (preview) {
                qstatus.innerHTML = `<span class="error_query">Can't create internal table.</span><br><span class="error_code">${e.message}</span>`;
            } else {
                qstatus.innerHTML = `<span class="error_code">${e.message}</span>`;
            }
        }

        return false;
    } 

    async function run_query(query, preview=false) {
        first_result = false

        var tid = setTimeout(show_loader, 300);
        var qstatus = document.getElementById('query_status');
        qstatus.innerHTML = '<span class="elapsed">Running...</span>';

        var ret = false, data = [], conn, uindex;
        try {
            var elapsed = Date.now();
            for(let i=0; i<duck_dbs.length; i++) {
                if (!duck_dbs[i].in_using) {
                    uindex = i;
                    console.log('uindex', uindex);
                    break;
                }
            }

            duck_dbs[uindex].in_using = true;
            duck_dbs[uindex].running_main_query = true;
            conn = await duck_dbs[uindex].instance.connect();

            if (uindex == 0) {
                for (let i=0; i<internal_tables.length; i++) {
                    if (internal_tables[i].table.name && query.indexOf(`"${internal_tables[i].file.name}"`) > 0) {
                        query = query.replaceAll(`"${internal_tables[i].file.name}"`, `"${internal_tables[i].table.name}"`);
                    }
                }
            } else {
                for (let i=0; i<internal_tables.length; i++) {
                    if (query.indexOf(`"${internal_tables[i].table.name}"`) > 0) {
                        query = query.replaceAll(`"${internal_tables[i].table.name}"`, `"${internal_tables[i].file.name}"`);
                    }
                }
            }

            const result = await conn.send(query);

            let batch = (await result.next()).value;
            const field_names = []
            for (let field of batch.schema.fields) {
                field_names.push(field.name)
            }
            first_result = true
            while(batch.length > 0 && !cancel_query) {
                for (let row of batch) {
                    let r = {}
                    for (let f of field_names) {
                        r[f] = row[f];
                    }
                    data.push(r)
                }
                if (cancel_query) break;
                batch = (await result.next()).value;
                if (!batch) break;
            }
            
            await conn.close();

            if (cancel_query) {
                qstatus.innerHTML = `<span class="error_code">Query was canceled </span>`;
            } else {
                if (preview) {
                    qstatus.innerHTML = `<span class="elapsed">Preview :</span><span>100 rows</span>`;
                } else {
                    elapsed = Date.now() - elapsed
                    if (elapsed < 1000)
                        qstatus.innerHTML = `<span class="elapsed">Elapsed :</span><span>${elapsed} ms</span>`;
                    else {
                        elapsed = elapsed / 1000
                        qstatus.innerHTML = `<span class="elapsed">Elapsed :</span><span>${elapsed.toFixed(2)} s</span>`;
                    }
                }
            }

            ret = true;
        } 
        catch (e) {
            if (!preview) {
                qstatus.innerHTML = `<span class="error_code">${e.message}</span>`;
            }
            data = [];
        }

        clearTimeout(tid);
        
        duck_dbs[uindex].in_using = false;
        duck_dbs[uindex].running_main_query = false;

        document.getElementById("cancel_button").classList.remove("show_block");
        document.getElementById("loader").classList.remove("show_block");
        if (cancel_query)
            canvasgrid.data = [];
        else
            canvasgrid.data = data;

        return ret;
    }

    async function mount_duckdb_dir() {
        const out = {};
        const dirHandle = await showDirectoryPicker(); 
        const parquet_handle = await dirHandle.getDirectoryHandle( 'parquets', { create: true } );

        await handleDirectoryEntry( dirHandle, out );
        console.log( out );
    }
</script>
</html>