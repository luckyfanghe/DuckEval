<!DOCTYPE html>
<html>
<head>
    <title>DuckDB</title>
    <link rel="stylesheet" href="http://codemirror.net/lib/codemirror.css">
    <link rel="stylesheet" href="http://codemirror.net/addon/hint/show-hint.css">
    <link rel="stylesheet" href="./static/css/sortable-theme-bootstrap.css" />
    <link rel="stylesheet" href="./static/css/styles.css" />
    
    <script src="http://codemirror.net/lib/codemirror.js"></script>
    <script src="http://codemirror.net/addon/edit/matchbrackets.js"></script>
    <script src="http://codemirror.net/mode/sql/sql.js"></script>
    <script src="http://codemirror.net/addon/hint/show-hint.js"></script>
    <script src="http://codemirror.net/addon/hint/sql-hint.js"></script>
    <script src="http://codemirror.net/addon/comment/comment.js"></script>
    <script src="http://pure.github.io/pure/libs/pure.js"></script>
    <script src="https://unpkg.com/canvas-datagrid"></script>
    <script src="./static/js/pgsql_parser.js"></script>
    <script src="./static/js/sortable.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@6.1.5/build/iife/with-async-ittr-min.js"></script>
</head>

<body>
<div>
    <h2>SQL Editer</h2>
    <div class="sql_editer_container">
        <div class="left_panel">
            <button type="button" class="btn" style="float: left;" onclick="onClickPlay()"><img src="/static/images/play.svg" style="width: 15px; margin: 0;"></button>
            <textarea rows="4" cols="50" name="textarea_sql_editer" id="textarea_sql_editer">
    # Use '--' or '#' for comments.
    -- space needed after '--'
    -- use semicolon (;) at the end of multiline query

    SELECT 1 AS 'Result' 
        UNION SELECT 2
        UNION SELECT 3;
            </textarea>
        </div>
        <div class="right_panel">
            <table class="sortable-theme-bootstrap" data-sortable name="sortable_table" id="sortable_table">
                <thead id="thead">
                    <tr>
                        <th>Name</th>
                        <th>Size</th>
                        <th>FileLastModified</th>
                        <th>PreviewGenerated</th>
                        <th>Local Table</th>
                    </tr>
                </thead>
                <tbody id="tbody">
                </tbody>
            </table>
        </div>
    </div>
    <div class="file_browser_container">
        <!-- <label for="file-input">
            <img src="/static/images/upload.svg" style="width: 30px;"/>
        </label>
        <input id="file-input" type="file" /> -->
        <label for="qfile">Select files:</label>
        <input type="file" id="qfile" name="qfile" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
    </div>
    <div id="query_elapsed"></div>
    <div id="grid"></div>
</div>

<script>
    const libraryVersion = "0.0.41-dev427.0";
    // const libraryVersion = "0.1.12-dev54.0";
    const distURL = `https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@${libraryVersion}/dist/`;
    var duck_db, i_db, sql_editer, sql_parser;
    var internal_tables = [];

    DUCKDB_BUNDLES = ({
        asyncDefault: {
            mainModule: new URL('duckdb.wasm', distURL).toString(),
            mainWorker: new URL('duckdb-browser-async.worker.js', distURL).toString(),
        },
        asyncNext: {
            mainModule: new URL(`duckdb-next.wasm`, distURL).toString(),
            mainWorker: new URL('duckdb-browser-async-next.worker.js', distURL).toString(),
        },
        asyncNextCOI: {
            mainModule: new URL('duckdb-next-coi.wasm', distURL).toString(),
            mainWorker: new URL('duckdb-browser-async-next-coi.worker.js', distURL).toString(),
            pthreadWorker: new URL('duckdb-browser-async-next-coi.pthread.worker.js', distURL).toString(),
        },
    })

    async function makeDB() {
        const logger = new duckdb.ConsoleLogger();
        const worker = new Worker(workerURL);
        const db = new duckdb.AsyncDuckDB(logger, worker);
        await db.instantiate(wasmURL, pThreadURL);
        return db;
    }

    async function load() {
        duckdb = await import(`https://cdn.skypack.dev/@duckdb/duckdb-wasm@${libraryVersion}`);
        bundle = await duckdb.selectBundle(DUCKDB_BUNDLES);

        // download worker script
        let workerReq = await fetch(bundle.mainWorker);
        let workerScript = await workerReq.text();
        let workerScriptBlob = new Blob([workerScript], { type: 'application/javascript' });
        workerURL = URL.createObjectURL(workerScriptBlob);

        // download WASM
        let wasmReq = await fetch(bundle.mainModule);
        wasmURL = URL.createObjectURL(await wasmReq.blob());

        // download Wasm
        if (!bundle.pthreadWorker) {
            pThreadURL = undefined;
        } else {
            let pthreadReq = await fetch(bundle.pthreadWorker);
            pThreadURL = URL.createObjectURL(await pthreadReq.blob());
        }

        const logger = new duckdb.ConsoleLogger();
        const worker = new Worker(workerURL);
        duck_db = new duckdb.AsyncDuckDB(logger, worker);
        await duck_db.instantiate(wasmURL, pThreadURL);
        console.log(duck_db.getVersion());
    }

    async function init_idb() {
        await idb.deleteDB('DuckEval');
        i_db = await idb.openDB('DuckEval', 2, {
            upgrade(i_db) {
                // Create a store of objects
                const store = i_db.createObjectStore('internal_tables', {
                    // The 'id' property of the object will be the key.
                    keyPath: 'id',
                    // If it isn't explicitly set, create a value by auto incrementing.
                    autoIncrement: true,
                });
                // Create an index on the 'tname' property of the objects.
                store.createIndex('tname', 'tname');
            },
        });
    }

    window.onload = function () { 
        sql_editer = CodeMirror.fromTextArea(document.getElementById('textarea_sql_editer'), {
            mode: "text/x-mysql",
            lineNumbers: true,
            indentWithTabs: true,
            smartIndent: true,
            lineNumbers: true,
            matchBrackets : true,
            autofocus: true,
            extraKeys: {
                "Ctrl-Space": "autocomplete",
                "Cmd-Enter":  function(cm) {
                    onClickPlay()
                },
                'Cmd-/': function(cm) {
                    sql_editer.execCommand('toggleComment')
                }
            },
            hintOptions: {tables: {
                users: {name: null, score: null, birthDate: null},
                countries: {name: null, population: null, size: null}
            }}
        });
        sql_parser = new NodeSQLParser.Parser();
        load();
        init_idb();
    };

    const qfile_input = document.getElementById("qfile");
    qfile_input.addEventListener("change", registerFile, false);
    async function registerFile() {
        duck_db.registerFileHandle(this.files[0].name, this.files[0]);

        let existTable = false
        for (let i=0; i<internal_tables.length; i++) {
            if (internal_tables[i].name == this.files[0].name) {
                existTable = true;
                break;
            }
        }
        if (!existTable) {
            internal_tables.push({
                name: this.files[0].name,
                size: this.files[0].size,
                lastmodified: new Date(this.files[0].lastModified).toUTCString(),
                preview: 'No',
                localtable: ''
            });
            refresh_internal_table();
        }

        preview_time = Date.now()
        let preview = await run_query(`SELECT * FROM '${this.files[0].name}' LIMIT 100`, true);
        setTimeout(background_process(this.files[0], preview, (Date.now()-preview_time)/1000), 100);
    }

    function background_process(file, preview, elapsed) {
        const table_name = file.name.split('.')[0].toLowerCase();
        for (let i=0; i<internal_tables.length; i++) {
            if (internal_tables[i].name == file.name) {
                internal_tables[i].preview = preview ? `Yes (${elapsed.toFixed(2)}s)`: 'No';
                refresh_internal_table();

                if (internal_tables[i].localtable == '') {
                    elapsed = Date.now()
                    run_only_query(`CREATE TABLE IF NOT EXISTS '${table_name}' AS (SELECT * FROM '${file.name}')`, true).then((res) => {
                        if (res) {
                            elapsed = (Date.now() - elapsed) / 1000
                            internal_tables[i].localtable = `${table_name} (${elapsed.toFixed(2)}s)`;
                            refresh_internal_table();
                            update_idb(table_name);
                        }
                    })
                }
                break;
            }
        }
    }

    function refresh_internal_table() {
        var tbody = document.getElementById("tbody");

        while (tbody.hasChildNodes()) {
            tbody.removeChild(tbody.lastChild);
        }

        for (let t of internal_tables) {
            var tr = document.createElement("tr");
            for (let k in t) {
                addCell(tr, "td", t[k]);
            }
            tbody.appendChild(tr);
        }

        Sortable.initTable(document.querySelector('#sortable_table'))
    }

    async function update_idb(table_name) {
        await i_db.add('internal_tables', {tname: table_name});
        console.log(await i_db.getAllFromIndex('internal_tables', 'tname'));
    }

    function onClickPlay() {
        let selected = sql_editer.getSelection();
        if (selected) {
            run_query(selected.replaceAll('#', '-- '));
            return;
        }
        
        let query = sql_editer.getValue();
        let ast, sql;
        query = query.replaceAll('#', '-- ');

        try {
            ast = sql_parser.astify(query);
            if (typeof(ast) == 'undefined' || typeof(ast.length) == 'undefined') {
                if (ast.type != null && ast.columns.length > 0) {
                    run_query(query);
                }
                return;
            } 
            if (ast.length == 1) {
                sql = sql_parser.sqlify(ast);
                run_query(sql);
                return;
            }
        } catch (e) {
            var div = document.getElementById('query_elapsed');
            div.innerHTML = `<span class="error_code">${e.message}</span>`;
            return
        }

        let cursor = sql_editer.getCursor();
        if (cursor.line == 0) {
            sql = sql_parser.sqlify(ast[0]);
            run_query(sql);
            return;
        }

        queries = query.split('\n');
        query = ''
        for (let i=cursor.line-1; i>0; i--) { // scan up direction of current cursor
            line = queries[i].trim();
            if (line.startsWith("-- ") || line.startsWith("#"))
                continue;

            if (line.indexOf(";") > 0)
                break;

            if (line.length > 0)
                query = line + '\n' + query;
        }

        for (let i=cursor.line; i<queries.length; i++) { // scan down direction of current cursor
            line = queries[i].trim();
            if (line.startsWith("-- ") || line.startsWith("#"))
                continue;

            if (line.length > 0) {
                query += line + '\n';
                if (line.indexOf(";") > 0)
                   break;
            }
        }

        if (query) {
            ast = sql_parser.astify(query);
            if (typeof(ast) == 'undefined' || typeof(ast.length) == 'undefined') {
                if (ast.type != null && ast.columns.length > 0) {
                    run_query(query);
                }
                return;
            }
            
            sql = sql_parser.sqlify(ast);
            run_query(sql);
        }
    }

    async function run_only_query(query, preview=false) {
        try {
            const conn = await duck_db.connect();
            await conn.runQuery(query);
            await conn.close();
            return true;
        } 
        catch (e) {
            var div = document.getElementById('query_elapsed');
            if (preview) {
                div.innerHTML = `<span class="error_query">Can't create internal table.</span><br><span class="error_code">${e.message}</span>`;
            } else {
                div.innerHTML = `<span class="error_code">${e.message}</span>`;
            }
        }

        return false;
    } 

    async function run_query(query, preview=false) {
        try {
            const conn = await duck_db.connect();
            const elapsed = Date.now();
            // const result = await conn.runQuery(query);
            const result = await conn.sendQuery(query);

            let batch = (await result.next()).value;
            const field_names = []
            for (let field of batch.schema.fields) {
                field_names.push(field.name)
            }

            var data = []
            while(batch.length > 0) {
                for (let row of batch) {
                    let r = {}
                    for (let f of field_names) {
                        r[f] = row[f];
                    }
                    data.push(r)
                }
                batch = (await result.next()).value;
                if (!batch) break;
            }
            
            await conn.close();
            
            var div = document.getElementById('query_elapsed');
            if (preview) {
                div.innerHTML = `<span class="elapsed">Preview :</span><span>100 rows</span>`;
            } else {
                div.innerHTML = `<span class="elapsed">Elapsed :</span><span>${Date.now() - elapsed} ms</span>`;
            }

            load_data_with_canvasgrid(data);

            return true;
        } 
        catch (e) {
            if (!preview) {
                var div = document.getElementById('query_elapsed');
                div.innerHTML = `<span class="error_code">${e.message}</span>`;
            }
            load_data_with_canvasgrid(null);
        }

        return false;
    }

    function load_data_with_canvasgrid(data) {
        var parentNode = document.getElementById('grid');
        parentNode.innerHTML = ''

        if (data) {
            var grid = canvasDatagrid({
                parentNode: parentNode,
                style: {
                    overflowX: 'hidden',
                    overflowY: 'hidden',
                }
            });

            grid.style.cellWidth = 150;
            grid.style.height = '500px';
            grid.style.width = '100%';
            grid.data = data;
        }
    }

    function load_data_with_sortabletable(rows) {
        var thead = document.getElementById("thead");
        var tbody = document.getElementById("tbody");

        while (thead.hasChildNodes()) {
            thead.removeChild(thead.lastChild);
        }
        while (tbody.hasChildNodes()) {
            tbody.removeChild(tbody.lastChild);
        }

        var header_row = document.createElement("tr");
        var field_names = []
        for (let field of rows.schema.fields) {
            addCell(header_row, "th", `${field.name}`);
            field_names.push(field.name)
        }
        thead.appendChild(header_row);

        for (let row of rows) {
            var tr = document.createElement("tr");
            for (let f of field_names) {
                addCell(tr, "td", row[f]);
            }
            tbody.appendChild(tr);
        }

        Sortable.initTable(document.querySelector('#sortable_table'))
    }
    function addCell(tr, type, value) {
        var td = document.createElement(type)
        td.textContent = value;
        tr.appendChild(td);
    }
</script>
</html>